package orgservice
package main














































































































































































































































































































































































































































































}	_ = json.NewEncoder(w).Encode(payload)	w.WriteHeader(status)	w.Header().Set("Content-Type", "application/json")func writeJSON(w http.ResponseWriter, status int, payload any) {}	writeJSON(w, http.StatusOK, map[string]string{"status": "updated"})	}		return		writeJSON(w, http.StatusInternalServerError, map[string]string{"error": "db_error"})		log.Printf("Failed to update branch: %v", err)	if err != nil {		req.OpeningTime, req.ClosingTime, id, orgID)	`, req.Name, req.Slug, req.Address, req.City, req.Province, req.PostalCode, req.Phone, req.Email,		WHERE id = $11 AND organization_id = $12		                   phone = $7, email = $8, opening_time = $9, closing_time = $10, updated_at = NOW()		UPDATE branches SET name = $1, slug = $2, address = $3, city = $4, province = $5, postal_code = $6,	_, err := db.Exec(`	}		return		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "invalid_request"})	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {	var req CreateBranchRequest	}		return		writeJSON(w, http.StatusForbidden, map[string]string{"error": "cashier_cannot_update"})	if role == "CASHIER" {	}		return		writeJSON(w, http.StatusForbidden, map[string]string{"error": "access_denied"})	if role == "MANAGER" && userOrgID != orgID {	// MANAGER can only update branches in their org	userOrgID := r.Header.Get("X-Organization-ID")	role := r.Header.Get("X-User-Role")	id := vars["id"]	orgID := vars["orgId"]	vars := mux.Vars(r)func updateBranch(db *sql.DB, w http.ResponseWriter, r *http.Request) {}	writeJSON(w, http.StatusOK, b)	}		b.ClosingTime = closingTime.String	if closingTime.Valid {	}		b.OpeningTime = openingTime.String	if openingTime.Valid {	}		return		writeJSON(w, http.StatusInternalServerError, map[string]string{"error": "db_error"})		log.Printf("Failed to get branch: %v", err)	if err != nil {	}		return		writeJSON(w, http.StatusNotFound, map[string]string{"error": "branch_not_found"})	if err == sql.ErrNoRows {		&openingTime, &closingTime, &b.IsActive, &b.CreatedAt, &b.UpdatedAt)	`, id, orgID).Scan(&b.ID, &b.OrganizationID, &b.Name, &b.Slug, &b.Address, &b.City, &b.Province, &b.PostalCode, &b.Phone, &b.Email,		FROM branches WHERE id = $1 AND organization_id = $2		       opening_time, closing_time, is_active, created_at, updated_at		SELECT id, organization_id, name, slug, address, city, province, postal_code, phone, email,	err := db.QueryRow(`	var openingTime, closingTime sql.NullString	var b Branch	}		return		writeJSON(w, http.StatusForbidden, map[string]string{"error": "access_denied"})	if role == "CASHIER" && userBranchID != id {	// CASHIER can only see their own branch	}		return		writeJSON(w, http.StatusForbidden, map[string]string{"error": "access_denied"})	if role == "MANAGER" && userOrgID != orgID {	// MANAGER can only see branches in their org	userBranchID := r.Header.Get("X-Branch-ID")	userOrgID := r.Header.Get("X-Organization-ID")	role := r.Header.Get("X-User-Role")	id := vars["id"]	orgID := vars["orgId"]	vars := mux.Vars(r)func getBranch(db *sql.DB, w http.ResponseWriter, r *http.Request) {}	writeJSON(w, http.StatusCreated, map[string]any{"id": branchID, "name": req.Name})	}		return		writeJSON(w, http.StatusInternalServerError, map[string]string{"error": "db_error"})		log.Printf("Failed to create branch: %v", err)	if err != nil {		req.OpeningTime, req.ClosingTime)	`, branchID, orgID, req.Name, req.Slug, req.Address, req.City, req.Province, req.PostalCode, req.Phone, req.Email,		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, true, NOW(), NOW())		                      opening_time, closing_time, is_active, created_at, updated_at)		INSERT INTO branches (id, organization_id, name, slug, address, city, province, postal_code, phone, email,	_, err := db.Exec(`	branchID := uuid.New().String()	}		return		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "name_and_slug_required"})	if req.Name == "" || req.Slug == "" {	}		return		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "invalid_request"})	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {	var req CreateBranchRequest	}		return		writeJSON(w, http.StatusForbidden, map[string]string{"error": "cashier_cannot_create"})	if role == "CASHIER" {	}		return		writeJSON(w, http.StatusForbidden, map[string]string{"error": "access_denied"})	if role == "MANAGER" && userOrgID != orgID {	// MANAGER can only create branches in their org	userOrgID := r.Header.Get("X-Organization-ID")	role := r.Header.Get("X-User-Role")	orgID := mux.Vars(r)["orgId"]func createBranch(db *sql.DB, w http.ResponseWriter, r *http.Request) {}	writeJSON(w, http.StatusOK, map[string]any{"branches": branches})	}		branches = append(branches, b)		}			b.ClosingTime = closingTime.String		if closingTime.Valid {		}			b.OpeningTime = openingTime.String		if openingTime.Valid {			&openingTime, &closingTime, &b.IsActive, &b.CreatedAt, &b.UpdatedAt)		rows.Scan(&b.ID, &b.OrganizationID, &b.Name, &b.Slug, &b.Address, &b.City, &b.Province, &b.PostalCode, &b.Phone, &b.Email,		var openingTime, closingTime sql.NullString		var b Branch	for rows.Next() {	var branches []Branch	defer rows.Close()	}		return		writeJSON(w, http.StatusInternalServerError, map[string]string{"error": "db_error"})		log.Printf("Failed to list branches: %v", err)	if err != nil {	`, orgID)		FROM branches WHERE organization_id = $1 AND is_active = true ORDER BY created_at DESC		       opening_time, closing_time, is_active, created_at, updated_at		SELECT id, organization_id, name, slug, address, city, province, postal_code, phone, email, 	rows, err := db.Query(`	}		return		writeJSON(w, http.StatusForbidden, map[string]string{"error": "access_denied"})	if role == "MANAGER" && userOrgID != orgID {	// MANAGER can only see branches of their org	userOrgID := r.Header.Get("X-Organization-ID")	role := r.Header.Get("X-User-Role")	orgID := mux.Vars(r)["orgId"]func listBranches(db *sql.DB, w http.ResponseWriter, r *http.Request) {// Branches}	writeJSON(w, http.StatusOK, map[string]string{"status": "updated"})	}		return		writeJSON(w, http.StatusInternalServerError, map[string]string{"error": "db_error"})		log.Printf("Failed to update org: %v", err)	if err != nil {	`, req.Name, req.Slug, req.ContactEmail, req.ContactPhone, req.PlanType, id)		WHERE id = $6		UPDATE organizations SET name = $1, slug = $2, contact_email = $3, contact_phone = $4, plan_type = $5, updated_at = NOW()	_, err := db.Exec(`	}		return		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "invalid_request"})	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {	var req CreateOrgRequest	id := mux.Vars(r)["id"]	}		return		writeJSON(w, http.StatusForbidden, map[string]string{"error": "admin_required"})	if role != "ADMIN" {	role := r.Header.Get("X-User-Role")	// Only ADMIN can update orgsfunc updateOrganization(db *sql.DB, w http.ResponseWriter, r *http.Request) {}	writeJSON(w, http.StatusOK, org)	}		return		writeJSON(w, http.StatusForbidden, map[string]string{"error": "access_denied"})	if role == "MANAGER" && organizationID != id {	// MANAGER can only see their own org	}		return		writeJSON(w, http.StatusInternalServerError, map[string]string{"error": "db_error"})		log.Printf("Failed to get org: %v", err)	if err != nil {	}		return		writeJSON(w, http.StatusNotFound, map[string]string{"error": "org_not_found"})	if err == sql.ErrNoRows {	`, id).Scan(&org.ID, &org.Name, &org.Slug, &org.ContactEmail, &org.ContactPhone, &org.PlanType, &org.IsActive, &org.CreatedAt, &org.UpdatedAt)		FROM organizations WHERE id = $1		SELECT id, name, slug, contact_email, contact_phone, plan_type, is_active, created_at, updated_at	err := db.QueryRow(`	var org Organization	organizationID := r.Header.Get("X-Organization-ID")	role := r.Header.Get("X-User-Role")	id := mux.Vars(r)["id"]func getOrganization(db *sql.DB, w http.ResponseWriter, r *http.Request) {}	writeJSON(w, http.StatusCreated, map[string]any{"id": orgID, "name": req.Name})	}		return		writeJSON(w, http.StatusInternalServerError, map[string]string{"error": "db_error"})		log.Printf("Failed to create org: %v", err)	if err != nil {	`, orgID, req.Name, req.Slug, req.ContactEmail, req.ContactPhone, planType)		VALUES ($1, $2, $3, $4, $5, $6, true, NOW(), NOW())		INSERT INTO organizations (id, name, slug, contact_email, contact_phone, plan_type, is_active, created_at, updated_at)	_, err := db.Exec(`	}		planType = "FREE"	if planType == "" {	planType := req.PlanType	orgID := uuid.New().String()	}		return		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "name_and_slug_required"})	if req.Name == "" || req.Slug == "" {	}		return		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "invalid_request"})	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {	var req CreateOrgRequest	}		return		writeJSON(w, http.StatusForbidden, map[string]string{"error": "admin_required"})	if role != "ADMIN" {	role := r.Header.Get("X-User-Role")	// Only ADMIN can create orgsfunc createOrganization(db *sql.DB, w http.ResponseWriter, r *http.Request) {}	writeJSON(w, http.StatusOK, map[string]any{"organizations": orgs})	}		orgs = append(orgs, org)		rows.Scan(&org.ID, &org.Name, &org.Slug, &org.ContactEmail, &org.ContactPhone, &org.PlanType, &org.IsActive, &org.CreatedAt, &org.UpdatedAt)		var org Organization	for rows.Next() {	var orgs []Organization	defer rows.Close()	}		return		writeJSON(w, http.StatusInternalServerError, map[string]string{"error": "db_error"})		log.Printf("Failed to list orgs: %v", err)	if err != nil {	`)		FROM organizations WHERE is_active = true ORDER BY created_at DESC LIMIT 100		SELECT id, name, slug, contact_email, contact_phone, plan_type, is_active, created_at, updated_at	rows, err := db.Query(`	}		return		writeJSON(w, http.StatusForbidden, map[string]string{"error": "admin_required"})	if role != "ADMIN" {	role := r.Header.Get("X-User-Role")	// Only ADMIN can list all orgsfunc listOrganizations(db *sql.DB, w http.ResponseWriter, r *http.Request) {// Organizations}	}		log.Fatalf("Server error: %v", err)	if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {	log.Printf("Org service on port %s", port)	}()		server.Shutdown(context.Background())		<-sigch		signal.Notify(sigch, syscall.SIGTERM, syscall.SIGINT)		sigch := make(chan os.Signal, 1)	go func() {	}		Handler: router,		Addr:    fmt.Sprintf(":%s", port),	server := &http.Server{	}).Methods(http.MethodPut)		updateBranch(db, w, r)	router.HandleFunc("/api/organizations/{orgId}/branches/{id}", func(w http.ResponseWriter, r *http.Request) {	}).Methods(http.MethodGet)		getBranch(db, w, r)	router.HandleFunc("/api/organizations/{orgId}/branches/{id}", func(w http.ResponseWriter, r *http.Request) {	}).Methods(http.MethodPost)		createBranch(db, w, r)	router.HandleFunc("/api/organizations/{orgId}/branches", func(w http.ResponseWriter, r *http.Request) {	}).Methods(http.MethodGet)		listBranches(db, w, r)	router.HandleFunc("/api/organizations/{orgId}/branches", func(w http.ResponseWriter, r *http.Request) {	// Branches	}).Methods(http.MethodPut)		updateOrganization(db, w, r)	router.HandleFunc("/api/organizations/{id}", func(w http.ResponseWriter, r *http.Request) {	}).Methods(http.MethodGet)		getOrganization(db, w, r)	router.HandleFunc("/api/organizations/{id}", func(w http.ResponseWriter, r *http.Request) {	}).Methods(http.MethodPost)		createOrganization(db, w, r)	router.HandleFunc("/api/organizations", func(w http.ResponseWriter, r *http.Request) {	}).Methods(http.MethodGet)		listOrganizations(db, w, r)	router.HandleFunc("/api/organizations", func(w http.ResponseWriter, r *http.Request) {	// Organizations	}).Methods(http.MethodGet)		writeJSON(w, http.StatusOK, map[string]string{"status": "ok"})	router.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {	// Health check	router := mux.NewRouter()	}		log.Fatalf("DB ping failed: %v", err)	if err := db.Ping(); err != nil {	}		time.Sleep(time.Second)		log.Printf("Waiting for database... (%d/30)", i+1)		}			break		if err := db.Ping(); err == nil {	for i := 0; i < 30; i++ {	defer db.Close()	}		log.Fatalf("DB connect failed: %v", err)	if err != nil {	db, err := sql.Open("postgres", dbURL)	}		dbURL = "postgres://user:password@localhost:5432/pointofsale"	if dbURL == "" {	dbURL := os.Getenv("DATABASE_URL")	}		port = "8085"	if port == "" {	port := os.Getenv("PORT")func main() {}	ClosingTime string `json:"closing_time"`	OpeningTime string `json:"opening_time"`	Email       string `json:"email"`	Phone       string `json:"phone"`	PostalCode  string `json:"postal_code"`	Province    string `json:"province"`	City        string `json:"city"`	Address     string `json:"address"`	Slug        string `json:"slug"`	Name        string `json:"name"`type CreateBranchRequest struct {}	PlanType     string `json:"plan_type"`	ContactPhone string `json:"contact_phone"`	ContactEmail string `json:"contact_email"`	Slug         string `json:"slug"`	Name         string `json:"name"`type CreateOrgRequest struct {}	UpdatedAt      time.Time `json:"updated_at"`	CreatedAt      time.Time `json:"created_at"`	IsActive       bool      `json:"is_active"`	ClosingTime    string    `json:"closing_time"`	OpeningTime    string    `json:"opening_time"`	Email          string    `json:"email"`	Phone          string    `json:"phone"`	PostalCode     string    `json:"postal_code"`	Province       string    `json:"province"`	City           string    `json:"city"`	Address        string    `json:"address"`	Slug           string    `json:"slug"`	Name           string    `json:"name"`	OrganizationID string    `json:"organization_id"`	ID             string    `json:"id"`type Branch struct {}	UpdatedAt    time.Time `json:"updated_at"`	CreatedAt    time.Time `json:"created_at"`	IsActive     bool      `json:"is_active"`	PlanType     string    `json:"plan_type"`	ContactPhone string    `json:"contact_phone"`	ContactEmail string    `json:"contact_email"`	Slug         string    `json:"slug"`	Name         string    `json:"name"`	ID           string    `json:"id"`type Organization struct {)	_ "github.com/lib/pq"	"github.com/gorilla/mux"	"github.com/google/uuid"	"time"	"syscall"	"os/signal"	"os"	"net/http"	"log"	"fmt"	"encoding/json"	"database/sql"	"context"import (