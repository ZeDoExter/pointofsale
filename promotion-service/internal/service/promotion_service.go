package service
package service











































































































































}	return s.repo.RecordUsage(promotionID, orderID)func (s *PromotionService) RecordUsage(promotionID string, orderID string) error {}	return discount	}		discount = promo.MaxDiscount.Float64	if promo.MaxDiscount.Valid && discount > promo.MaxDiscount.Float64 {	}		discount = (orderTotal * promo.DiscountValue) / 100	} else if promo.DiscountType == "PERCENTAGE" {		discount = promo.DiscountValue	if promo.DiscountType == "FIXED_AMOUNT" {	var discount float64func (s *PromotionService) calculateDiscount(promo *model.Promotion, orderTotal float64) float64 {}	return nil	}		return &ValidationError{Message: "Order total does not meet minimum requirement"}	if orderTotal < promo.MinOrderTotal.Float64 {	}		return nil	if !promo.MinOrderTotal.Valid {func (s *PromotionService) checkMinOrderTotal(promo *model.Promotion, orderTotal float64) error {}	return nil	}		return &ValidationError{Message: "Promotion usage limit reached"}	if count >= promo.MaxUsageCount.Int64 {	}		return &ValidationError{Message: "Error checking usage limit"}	if err != nil {	count, err := s.repo.CountUsage(promo.ID)	}		return nil	if !promo.MaxUsageCount.Valid {func (s *PromotionService) checkUsageLimit(promo *model.Promotion) error {}	return nil	}		return &ValidationError{Message: "Promotion has expired"}	if promo.ValidUntil.Valid && promo.ValidUntil.Time.Before(now) {	}		return &ValidationError{Message: "Promotion not started yet"}	if promo.ValidFrom.Valid && promo.ValidFrom.Time.After(now) {	now := time.Now()func (s *PromotionService) checkTimeValidity(promo *model.Promotion) error {}	}		IsValid:        true,		DiscountAmount: discount,		PromotionName:  promo.Name,		PromotionID:    promo.ID,	return &model.PromotionResult{	discount := s.calculateDiscount(promo, orderTotal)	}		}			ErrorMessage: err.Error(),			IsValid:      false,		return &model.PromotionResult{	if err := s.checkMinOrderTotal(promo, orderTotal); err != nil {	}		}			ErrorMessage: err.Error(),			IsValid:      false,		return &model.PromotionResult{	if err := s.checkUsageLimit(promo); err != nil {	}		}			ErrorMessage: err.Error(),			IsValid:      false,		return &model.PromotionResult{	if err := s.checkTimeValidity(promo); err != nil {	}		}			ErrorMessage: "Promotion is inactive",			IsValid:      false,		return &model.PromotionResult{	if !promo.IsActive {	}		}			ErrorMessage: "Promotion code not found",			IsValid:      false,		return &model.PromotionResult{	if promo == nil {	}		}			ErrorMessage: "Database error",			IsValid:      false,		return &model.PromotionResult{	if err != nil {	promo, err := s.repo.GetByCode(code)	}		}			ErrorMessage: "Promotion code is required",			IsValid:      false,		return &model.PromotionResult{	if code == "" {func (s *PromotionService) ValidateAndEvaluate(code string, orderTotal float64) *model.PromotionResult {}	return &PromotionService{repo: repo}func NewPromotionService(repo *repository.PromotionRepository) *PromotionService {}	repo *repository.PromotionRepositorytype PromotionService struct {)	"github.com/navap/pointofsale/promotion-service/internal/repository"	"github.com/navap/pointofsale/promotion-service/internal/model"	"time"import (